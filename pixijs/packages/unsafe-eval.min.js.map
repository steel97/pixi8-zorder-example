{"version":3,"file":"unsafe-eval.min.js","sources":["../../src/unsafe-eval/generateUniformBufferSyncPolyfill.ts","../../src/unsafe-eval/generateUniformsSyncPolyfill.ts","../../src/unsafe-eval/init.ts"],"sourcesContent":["import { type UBOElement, WGSL_TO_STD40_SIZE } from '../rendering/renderers/shared/shader/utils/createUBOElements';\nimport { UBO_TO_SINGLE_SETTERS_FN } from '../rendering/renderers/shared/shader/utils/createUniformBufferSyncTypes';\nimport { uniformBufferParsers } from '../rendering/renderers/shared/shader/utils/uniformBufferParsers';\n\nimport type {\n    UBO_TYPE,\n    UniformsSyncCallback\n} from '../rendering/renderers/shared/shader/utils/createUniformBufferSyncTypes';\n\nexport function generateUniformBufferSyncPolyfill(\n    uboElements: UBOElement[],\n): UniformsSyncCallback\n{\n    return ((uv: any, data: any, o: any) =>\n    {\n        let v = null;\n        let t = 0;\n\n        let prev = 0;\n\n        for (let i = 0; i < uboElements.length; i++)\n        {\n            const uboElement = uboElements[i];\n\n            const name = uboElement.data.name;\n\n            let executed = false;\n            let offset = 0;\n\n            for (let j = 0; j < uniformBufferParsers.length; j++)\n            {\n                const uniformParser = uniformBufferParsers[j];\n\n                if (uniformParser.test(uboElement.data))\n                {\n                    offset = uboElement.offset / 4;\n\n                    o += offset - prev;\n\n                    uniformBufferParsers[j].exec(name, uv, data, o, v);\n\n                    executed = true;\n\n                    break;\n                }\n            }\n\n            if (!executed)\n            {\n                if (uboElement.data.size > 1)\n                {\n                    const rowSize = Math.max(WGSL_TO_STD40_SIZE[uboElement.data.type] / 16, 1);\n                    const elementSize = (uboElement.data.value as Array<number>).length / uboElement.data.size;\n\n                    const remainder = (4 - (elementSize % 4)) % 4;\n\n                    offset = uboElement.offset / 4;\n\n                    v = uv[name];\n                    o += offset - prev;\n\n                    let arrayOffset = o;\n\n                    t = 0;\n\n                    for (let i = 0; i < uboElement.data.size * rowSize; i++)\n                    {\n                        for (let j = 0; j < elementSize; j++)\n                        {\n                            data[arrayOffset++] = v[t++];\n                        }\n                        if (remainder !== 0)\n                        {\n                            arrayOffset += remainder;\n                        }\n                    }\n                }\n                else\n                {\n                    const template = UBO_TO_SINGLE_SETTERS_FN[uboElement.data.type as UBO_TYPE];\n\n                    offset = uboElement.offset / 4;\n\n                    v = uv[name];\n                    o += offset - prev;\n                    template(data, o, v);\n                }\n            }\n\n            prev = offset;\n        }\n    }) as UniformsSyncCallback;\n}\n","import {\n    GLSL_TO_ARRAY_SETTERS_FN,\n    GLSL_TO_SINGLE_SETTERS_FN_CACHED\n} from '../rendering/renderers/gl/shader/program/generateUniformsSyncTypes';\nimport { uniformParsers } from '../rendering/renderers/gl/shader/program/uniformParsers';\nimport { BufferResource } from '../rendering/renderers/shared/buffer/BufferResource';\nimport { UniformGroup } from '../rendering/renderers/shared/shader/UniformGroup';\n\nimport type { GlUniformData } from '../rendering/renderers/gl/shader/GlProgram';\nimport type { GLSL_TYPE } from '../rendering/renderers/gl/shader/program/generateUniformsSyncTypes';\nimport type { UniformsSyncCallback } from '../rendering/renderers/shared/shader/utils/createUniformBufferSyncTypes';\n\nexport function generateUniformsSyncPolyfill(\n    group: UniformGroup,\n    uniformData: Record<string, GlUniformData>\n): UniformsSyncCallback\n{\n    return ((ud: any, uv: any, renderer: any, syncData: any) =>\n    {\n        let v = null;\n        let cv = null;\n        let cu = null;\n        const t = 0;\n        const gl = renderer.gl;\n\n        for (const i in group.uniforms)\n        {\n            const data = uniformData[i];\n\n            if (!data)\n            {\n                if (group.uniforms[i] instanceof UniformGroup)\n                {\n                    if ((group.uniforms[i] as UniformGroup).ubo)\n                    {\n                        renderer.shader.bindUniformBlock(uv[i], i);\n                    }\n                    else\n                    {\n                        renderer.shader.updateUniformGroup(uv[i]);\n                    }\n                }\n                else if (group.uniforms[i] instanceof BufferResource)\n                {\n                    renderer.shader.bindBufferResource(uv[i], i);\n                }\n\n                continue;\n            }\n\n            const uniform = group.uniforms[i];\n\n            let executed = false;\n\n            for (let j = 0; j < uniformParsers.length; j++)\n            {\n                if (uniformParsers[j].test(data, uniform))\n                {\n                    uniformParsers[j].exec(i, cv, ud, uv, v, t, gl, renderer, syncData);\n                    executed = true;\n\n                    break;\n                }\n            }\n\n            if (!executed)\n            {\n                cu = ud[i];\n                cv = cu.value;\n                v = uv[i];\n\n                const isSingleSetter = data.size === 1 && !data.isArray;\n\n                if (isSingleSetter)\n                {\n                    GLSL_TO_SINGLE_SETTERS_FN_CACHED[data.type as GLSL_TYPE](cu, cv, v, ud[i].location, gl);\n                }\n                else\n                {\n                    GLSL_TO_ARRAY_SETTERS_FN[data.type as GLSL_TYPE](v, ud[i].location, gl);\n                }\n\n                cu = ud[i];\n                cv = cu.value;\n                v = uv[i];\n            }\n        }\n    }) as UniformsSyncCallback;\n}\n\n","import { GlUniformGroupSystem } from '../rendering/renderers/gl/shader/GlUniformGroupSystem';\nimport { UniformBufferSystem } from '../rendering/renderers/shared/shader/UniformBufferSystem';\nimport { generateUniformBufferSyncPolyfill } from './generateUniformBufferSyncPolyfill';\nimport { generateUniformsSyncPolyfill } from './generateUniformsSyncPolyfill';\n\nfunction selfInstall()\n{\n    Object.assign(GlUniformGroupSystem.prototype,\n        {\n            _systemCheck()\n            {\n                // Do nothing, don't throw error\n            },\n\n            // use polyfill which avoids eval method\n            _generateUniformsSync: generateUniformsSyncPolyfill,\n        }\n    );\n\n    Object.assign(UniformBufferSystem.prototype,\n        {\n            _systemCheck()\n            {\n                // Do nothing, don't throw error\n            },\n\n            // use polyfill which avoids eval method\n            _generateUniformBufferSync: generateUniformBufferSyncPolyfill,\n        }\n    );\n}\n\nselfInstall();\n"],"names":["generateUniformBufferSyncPolyfill","y","l","s","a","n","S","o","e","i","d","r","t","uniformBufferParsers","WGSL_TO_STD40_SIZE","uboElement","UBO_TO_SINGLE_SETTERS_FN","UniformGroup","BufferResource","uniformParsers","GLSL_TO_SINGLE_SETTERS_FN_CACHED","GLSL_TO_ARRAY_SETTERS_FN","GlUniformGroupSystem","UniformBufferSystem"],"mappings":"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"}